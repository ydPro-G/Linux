学习目录
1.什么是正则表达式？
2.正则表达式的基本语法
3.grep命令
4.sed流编辑器
5.awk文本处理语言
___________________________________________________________________________________________________________________________________
1.什么是正则表达式？
在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。正则表达式就是记录文本规则的代码。
下面通过grep，sed和awk命令来实际演示正则表达式如何使用。
参考网址：https://www.jb51.net/tools/zhengze.html
___________________________________________________________________________________________________________________________________
2.正则表达式的基本语法
一个正则表达式通常被称为一个pattern，为用来描述或者匹配一系列符合某个句法规则的字符串。

选择
|:表示选择。
实例： boy|girl可以匹配boy或girl。

限定数量
+:表示+号前面的字符必须出现至少一次或多次。
实例："goo+gle"可以匹配出gooogle，goooogle。

?;表示?前面的字符最多出现一次（0次或1次）。
实例："colou？r"可以匹配color，colour。

*:表示*前面的字符可以不出现也可以出现一次或多次。
实例："0*42"可以匹配42,042,0042,00042。

范围和优先级
()圆括号可以用来定义模式字符串的范围和优先级。

语法
\:将下一个字符标记为一个特殊字符或一个原义字符。
^:匹配输入字符串开始的位置。
$:匹配输入字符串的结束位置。
{n}:n是一个非负整数匹配确定的n次。
实例："o{2}"不能匹配Bob中的o，但是能匹配food中的两个o。
{n,}:n是一个非负整数，至少匹配n次。
实例："o{2,}"不能匹配Bob中的o，但是能匹配fooooood中的所有o。o{1,}等价于o+。o{0,}等价于o*.
{n,m}:m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。
*:匹配前面的子表达式零次或多次。例如，zo*能匹配“z”、“zo”以及“zoo”。*等价于{0,}
+:匹配前面的子表达式一次或多次。
?:匹配前面的子表达式零次或一次。
.:匹配除\n之外的任何单个字符。
（pattern）:匹配pattern并获取这一匹配的子字符串。
x|y:匹配x或y。
[xyz]:字符集合。匹配所包含的任一字符。
[^xyz]:排除型字符集合。匹配未列出的任意字符。
[a-z]:字符范围。匹配指定范围内的任意字符。
[^a-z]:排除型字符范围。匹配任何不在指定范围内的任意字符。
【思维导图】
___________________________________________________________________________________________________________________________________
3.grep命令
grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。

grep支持的三种正则表达式引擎
1.-E:POSIX扩展正则表达式 ERE
2.-G：POSIX基本正则表达式 BRE
3.-p：perl正则表达式 PCRE
grep命令参考网址：https://wangchujiang.com/linux-command/c/grep.html

使用正则表达式BRE
实例：

位置：
grep '^a' /etc/passwd  #查找/etc/passwd文件中以a开头的行

数量：
echo zero\nzo\nzoo | grep 'z.*o'   #匹配以z开头以o结尾的所有字符串。
echo zero\nzo\nzoo | grep 'z.o'    #匹配以z开头的以o结尾中间包含任一字符的字符串。
echo zero\nzo\nzoo | grep 'zo*'    #匹配以z开头以任意多个o结尾的字符串

选择：
nl /etc/passwd | grep '[a-z]'   #匹配/etc/passwd中所有的小写字母
nl /etc/passwd | grep '[0-9]'   #匹配/etc/passwd所有数字
nl /etc/passwd | grep '[[:digit:]]'   #匹配/etc/passwd所有数字
nl /etc/passwd | grep '[[:lower:]]'   #匹配/etc/passwd所有小写字母
nl /etc/passwd | grep '[[:upper:]]'   #匹配/etc/passwd所有大写字母
nl /etc/passwd | grep '[[:alnum:]]'   #匹配/etc/passwd所有字母和数字
nl /etc/passwd | grep '[[:alpha:]]'   #匹配/etc/passwd所有字母

排除字符
echo 'geek\ngood' | grep '[^o]'    #当^放入[]代表排除字符，o不显示
使用扩展正则表达式ERE
要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。
实例：

数量：
nl /etc/passwd | grep -E 'zo{1}'    #只匹配zo
echo 'zero\nzo\nzoo' | grep -E 'zo{1,}'    #匹配以zo开头的所有单词  

选择：
echo 'www.baidu.com\nwww.google.com\nwww.bing.com' | grep -E 'www\.(google|bing)\.com'   
#匹配www.google.com和www.bing.com
echo 'www.baidu.com\nwww.google.com\nwww.bing.com' | grep -Ev 'www\.baidu\.com'
#匹配不包含www.baidu.com的内容
PS：.号有特殊含义，需要\转义符来转义
___________________________________________________________________________________________________________________________________
4.sed流编辑器
功能强大的流式文本编辑器。
sed 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。

sed基本格式
sed [参数]... [执行命令][输入文件]...
sed命令参考网址：https://wangchujiang.com/linux-command/c/sed.html

sed动作指令
s:行内替换
c:整行替换
a:插到指定行的后面
i:插到指定行的前面
p:打印指定行，通常与-n参数配合使用
d:删除指定行
实例：

打印指定行（p）:
nl passwd（文件） | sed -n '2,5p'    #打印2-5行
nl passwd（文件） | sed -n '1~2p'    #打印奇数行

行内替换（s）：
sed -n 's/zsh/hehe/gp' passwd(文件)
#将输入文本中zsh全局替换为hehe，并且只打印替换的那一行

删除某行（d）:
sed -i '30d' passwd(文件)    #删除30行
___________________________________________________________________________________________________________________________________
5.awk文本处理语言
文本和数据进行处理的编程语言。
awk 是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。
操作基于pattern {action}完成。
实例：

准备：
vim test    #使用vim新建一个文本文档
I like Linux 
www.github.com    #输入以上内容

将文本内容打印到终端
1.
awk '{
print
}' test
2.
awk '{print}' test    #可以写多行也可以写一行

将test第一行的每个字段单独显示为一行
awk '{
if(NR==1){
print $1 "\n" $2 "\n" $3 "\n"
} else {
print}
}' test    #NR是awk内建的变量，表示当前处理的行数。 $n中的n为相应的字段号
或者
awk '{
if(NR==1){
OFS="\n"
print $1,$2,$3
} else {
print}
}' test    #OFS是awk内建的变量，表示输出时的字段分隔符，默认为空格。    

将test的第二行以点分布的字段换成以空格为分隔
awk -F'.' '{
if(NR==2){
print $1 "\t" $2 "\t" $3 "\t"    #print打印的非变量内容都需要用""包围起来
}}' test    #-F用来预先指定待处理记录的字段分隔符
或者
awk '
BEGIN{    #BEGIN这个表达式指示了其后的动作将在所有动作之前执行。
FS="."
OFS="\t"
}{
if(NR==2){
print $1,$2,$3
}}' test    
参考网址1：https://coolshell.cn/articles/9070.html
参考网址2：https://awk.readthedocs.io/en/latest/chapter-one.html
